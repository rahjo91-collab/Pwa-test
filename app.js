// Load version from version.json (generated by npm run version:stamp)
fetch('./version.json')
  .then(r => r.json())
  .then(v => {
    const el = document.getElementById('app-version');
    if (el) el.textContent = v.label;
  })
  .catch(() => {});

// Register Service Worker
let swRegistration = null;

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js')
      .then((registration) => {
        console.log('Service Worker registered successfully:', registration.scope);
        swRegistration = registration;
        updateServiceWorkerStatus('Service Worker: Active ‚úì');

        // Check notification status after service worker is ready
        updateNotificationStatus();
      })
      .catch((error) => {
        console.log('Service Worker registration failed:', error);
        updateServiceWorkerStatus('Service Worker: Failed ‚úó');
      });
  });
} else {
  updateServiceWorkerStatus('Service Worker: Not supported');
}

// Update Service Worker status in UI
function updateServiceWorkerStatus(message) {
  const statusElement = document.getElementById('sw-status');
  if (statusElement) {
    statusElement.textContent = message;
    statusElement.className = message.includes('Active') ? 'status-success' : 'status-error';
  }
}

// Handle PWA installation
let deferredPrompt;
const installBtn = document.getElementById('install-btn');

window.addEventListener('beforeinstallprompt', (e) => {
  console.log('beforeinstallprompt event fired');
  // Prevent the mini-infobar from appearing
  e.preventDefault();
  // Stash the event so it can be triggered later
  deferredPrompt = e;
  // Show install button
  if (installBtn) {
    installBtn.style.display = 'block';
  }
});

if (installBtn) {
  installBtn.addEventListener('click', async () => {
    if (deferredPrompt) {
      // Show the install prompt
      deferredPrompt.prompt();
      // Wait for the user's response
      const { outcome } = await deferredPrompt.userChoice;
      console.log(`User response: ${outcome}`);
      // Clear the deferredPrompt
      deferredPrompt = null;
      // Hide the install button
      installBtn.style.display = 'none';
    }
  });
}

// Handle successful installation
window.addEventListener('appinstalled', () => {
  console.log('PWA was installed successfully');
  deferredPrompt = null;
  if (installBtn) {
    installBtn.style.display = 'none';
  }
});

// Check if app is already installed
if (window.matchMedia('(display-mode: standalone)').matches) {
  console.log('App is running in standalone mode');
  if (installBtn) {
    installBtn.style.display = 'none';
  }
}

// ==========================================
// PUSH NOTIFICATIONS
// ==========================================

const notificationStatus = document.getElementById('notification-status');
const enableNotificationsBtn = document.getElementById('enable-notifications-btn');
const sendNotificationBtn = document.getElementById('send-notification-btn');

// Check notification permission status
function updateNotificationStatus() {
  if (!('Notification' in window)) {
    notificationStatus.textContent = '‚ùå Notifications not supported in this browser';
    enableNotificationsBtn.disabled = true;
    return;
  }

  const permission = Notification.permission;
  if (permission === 'granted') {
    notificationStatus.textContent = '‚úÖ Notifications enabled';
    enableNotificationsBtn.style.display = 'none';
    sendNotificationBtn.disabled = false;
  } else if (permission === 'denied') {
    notificationStatus.textContent = '‚ùå Notifications blocked. Enable in browser settings.';
    enableNotificationsBtn.disabled = true;
  } else {
    notificationStatus.textContent = '‚ö†Ô∏è Notifications not enabled';
    enableNotificationsBtn.disabled = false;
  }
}

// Request notification permission
if (enableNotificationsBtn) {
  enableNotificationsBtn.addEventListener('click', async () => {
    // Check for secure context (HTTPS or localhost) - required for notifications
    if (window.isSecureContext === false) {
      notificationStatus.textContent = '‚ùå Notifications require HTTPS. Use localhost or deploy to HTTPS.';
      notificationStatus.style.background = '#ffebee';
      return;
    }

    // Check if Notification API is available
    if (!('Notification' in window)) {
      notificationStatus.textContent = '‚ùå Notifications not supported in this browser';
      enableNotificationsBtn.disabled = true;
      return;
    }

    // Give immediate visual feedback
    enableNotificationsBtn.disabled = true;
    enableNotificationsBtn.textContent = 'Requesting Permission...';
    notificationStatus.textContent = '‚è≥ Waiting for permission...';

    try {
      const permission = await Notification.requestPermission();
      console.log('Notification permission:', permission);
      updateNotificationStatus();

      // Restore button if permission wasn't granted
      if (permission !== 'granted') {
        enableNotificationsBtn.disabled = false;
        enableNotificationsBtn.textContent = 'Enable Notifications';
      }

      if (permission === 'granted') {
        // Send a welcome notification using service worker
        await showNotification('PWA Notifications Enabled! üéâ', {
          body: 'You will now receive notifications from this app. Click to test!',
          icon: './icon-192x192.png',
          badge: './icon-192x192.png',
          tag: 'welcome-notification',
          vibrate: [200, 100, 200],
          actions: [
            { action: 'explore', title: 'Explore App' },
            { action: 'close', title: 'Close' }
          ]
        });
      }
    } catch (error) {
      console.error('Error requesting notification permission:', error);
      notificationStatus.textContent = '‚ùå Error enabling notifications: ' + error.message;
      notificationStatus.style.background = '#ffebee';
      enableNotificationsBtn.disabled = false;
      enableNotificationsBtn.textContent = 'Enable Notifications';
    }
  });
}

// Helper function to show notification (uses service worker when available)
async function showNotification(title, options) {
  try {
    if ('serviceWorker' in navigator) {
      // Wait for an active service worker (required on mobile, more reliable everywhere)
      const registration = await navigator.serviceWorker.ready;
      await registration.showNotification(title, options);
      console.log('Notification shown via Service Worker');
    } else {
      // Fallback to regular Notification API for browsers without service worker support
      const notification = new Notification(title, options);

      // Add click handler for regular notifications
      notification.onclick = function(event) {
        event.preventDefault();
        console.log('Notification clicked:', title);
        window.focus();
        notification.close();
      };

      console.log('Notification shown via Notification API');
    }
  } catch (error) {
    console.error('Error showing notification:', error);
    throw error;
  }
}

// Send test notification
if (sendNotificationBtn) {
  sendNotificationBtn.addEventListener('click', async () => {
    if (Notification.permission === 'granted') {
      const notifications = [
        {
          title: 'Test Notification üì±',
          body: 'This is a test notification from your PWA! Click me to interact.',
          data: { url: './' }
        },
        {
          title: 'PWA Update üöÄ',
          body: 'Check out the new features: Push Notifications & Storage!',
          data: { url: './' }
        },
        {
          title: 'Reminder üîî',
          body: 'PWAs can work offline, cache content, and send notifications!',
          data: { url: './' }
        },
        {
          title: 'Storage Demo üíæ',
          body: 'Your data is safely stored locally using IndexedDB!',
          data: { url: './' }
        }
      ];

      const randomNotification = notifications[Math.floor(Math.random() * notifications.length)];

      try {
        await showNotification(randomNotification.title, {
          body: randomNotification.body,
          icon: './icon-192x192.png',
          badge: './icon-192x192.png',
          tag: 'test-notification-' + Date.now(),
          requireInteraction: false,
          vibrate: [200, 100, 200],
          data: randomNotification.data,
          actions: [
            { action: 'open', title: 'Open App', icon: './icon-192x192.png' },
            { action: 'dismiss', title: 'Dismiss' }
          ]
        });

        // Update status
        notificationStatus.textContent = '‚úÖ Test notification sent! Check your system tray.';
        notificationStatus.style.background = '#e8f5e9';

        setTimeout(() => {
          notificationStatus.textContent = '‚úÖ Notifications enabled';
          notificationStatus.style.background = '#f0f0f0';
        }, 3000);

        console.log('Test notification sent successfully');
      } catch (error) {
        console.error('Error sending test notification:', error);
        notificationStatus.textContent = '‚ùå Error sending notification';
        notificationStatus.style.background = '#ffebee';
      }
    }
  });
}

// ==========================================
// LOCAL STORAGE
// ==========================================

const storageKey = document.getElementById('storage-key');
const storageValue = document.getElementById('storage-value');
const saveLocalBtn = document.getElementById('save-local-btn');
const loadLocalBtn = document.getElementById('load-local-btn');
const clearLocalBtn = document.getElementById('clear-local-btn');
const localStorageResult = document.getElementById('local-storage-result');

// Save to localStorage
if (saveLocalBtn) {
  saveLocalBtn.addEventListener('click', () => {
    const key = storageKey.value.trim();
    const value = storageValue.value.trim();

    if (key && value) {
      try {
        localStorage.setItem(key, value);
        localStorageResult.textContent = `‚úÖ Saved: ${key} = "${value}"`;
        localStorageResult.style.borderColor = '#34a853';
        console.log('Saved to localStorage:', { key, value });
      } catch (error) {
        localStorageResult.textContent = `‚ùå Error: ${error.message}`;
        localStorageResult.style.borderColor = '#ea4335';
      }
    } else {
      localStorageResult.textContent = '‚ö†Ô∏è Please enter both key and value';
      localStorageResult.style.borderColor = '#fbbc04';
    }
  });
}

// Load from localStorage
if (loadLocalBtn) {
  loadLocalBtn.addEventListener('click', () => {
    const key = storageKey.value.trim();

    if (key) {
      const value = localStorage.getItem(key);
      if (value !== null) {
        storageValue.value = value;
        localStorageResult.textContent = `‚úÖ Loaded: ${key} = "${value}"`;
        localStorageResult.style.borderColor = '#34a853';
        console.log('Loaded from localStorage:', { key, value });
      } else {
        localStorageResult.textContent = `‚ùå Key "${key}" not found`;
        localStorageResult.style.borderColor = '#ea4335';
      }
    } else {
      localStorageResult.textContent = '‚ö†Ô∏è Please enter a key';
      localStorageResult.style.borderColor = '#fbbc04';
    }
  });
}

// Clear localStorage
if (clearLocalBtn) {
  clearLocalBtn.addEventListener('click', () => {
    const key = storageKey.value.trim();

    if (key) {
      localStorage.removeItem(key);
      localStorageResult.textContent = `‚úÖ Cleared key: "${key}"`;
      localStorageResult.style.borderColor = '#34a853';
      storageValue.value = '';
      console.log('Cleared from localStorage:', key);
    } else {
      localStorageResult.textContent = '‚ö†Ô∏è Please enter a key to clear';
      localStorageResult.style.borderColor = '#fbbc04';
    }
  });
}

// ==========================================
// SHARED TODO LIST (IndexedDB + Notifications)
// ==========================================

const taskInput = document.getElementById('task-input');
const taskReminder = document.getElementById('task-reminder');
const snoozeDuration = document.getElementById('snooze-duration');
const addTaskBtn = document.getElementById('add-task-btn');
const clearTasksBtn = document.getElementById('clear-tasks-btn');
const tasksList = document.getElementById('tasks-list');
const indexedDBResult = document.getElementById('indexeddb-result');
const activeReminders = document.getElementById('active-reminders');

let db;

// Track scheduled reminder timeouts so we can cancel them
const reminderTimers = {};

// Initialize IndexedDB (v2 adds reminderTime + completed fields)
function initIndexedDB() {
  const request = indexedDB.open('PWA_Database', 2);

  request.onerror = () => {
    console.error('IndexedDB error:', request.error);
    indexedDBResult.textContent = '‚ùå IndexedDB not available';
    indexedDBResult.style.borderColor = '#ea4335';
  };

  request.onsuccess = () => {
    db = request.result;
    console.log('IndexedDB initialized');
    loadTasks();
  };

  request.onupgradeneeded = (event) => {
    db = event.target.result;

    if (!db.objectStoreNames.contains('tasks')) {
      const objectStore = db.createObjectStore('tasks', { keyPath: 'id', autoIncrement: true });
      objectStore.createIndex('text', 'text', { unique: false });
      objectStore.createIndex('timestamp', 'timestamp', { unique: false });
      objectStore.createIndex('reminderTime', 'reminderTime', { unique: false });
      objectStore.createIndex('completed', 'completed', { unique: false });
    } else {
      const objectStore = event.target.transaction.objectStore('tasks');
      if (!objectStore.indexNames.contains('reminderTime')) {
        objectStore.createIndex('reminderTime', 'reminderTime', { unique: false });
      }
      if (!objectStore.indexNames.contains('completed')) {
        objectStore.createIndex('completed', 'completed', { unique: false });
      }
    }
    console.log('IndexedDB schema upgraded to v2');
  };
}

// Add task to IndexedDB
function addTask(text, reminderTime) {
  const transaction = db.transaction(['tasks'], 'readwrite');
  const objectStore = transaction.objectStore('tasks');

  const task = {
    text: text,
    timestamp: new Date().toISOString(),
    reminderTime: reminderTime || null,
    completed: false
  };

  const request = objectStore.add(task);

  request.onsuccess = () => {
    const taskId = request.result;
    console.log('Task added to IndexedDB:', { ...task, id: taskId });
    indexedDBResult.textContent = `‚úÖ Task added: "${text}"`;
    indexedDBResult.style.borderColor = '#34a853';

    // Schedule reminder if set
    if (reminderTime) {
      scheduleReminder(taskId, text, reminderTime);
    }

    // Send "task added" notification if permissions granted
    if (Notification.permission === 'granted') {
      showNotification('Task Added ‚úÖ', {
        body: text + (reminderTime ? ` (reminder: ${formatTime(reminderTime)})` : ''),
        icon: './icon-192x192.png',
        badge: './icon-192x192.png',
        tag: 'task-added-' + taskId,
        data: { type: 'task-added', taskId: taskId, url: './' }
      });
    }

    loadTasks();
  };

  request.onerror = () => {
    console.error('Error adding task:', request.error);
    indexedDBResult.textContent = '‚ùå Error adding task';
    indexedDBResult.style.borderColor = '#ea4335';
  };
}

// Schedule a reminder notification for a task
function scheduleReminder(taskId, text, reminderTime) {
  const delay = new Date(reminderTime).getTime() - Date.now();

  if (delay <= 0) {
    // Reminder is in the past, fire immediately
    fireReminderNotification(taskId, text);
    return;
  }

  // Cancel existing timer for this task if any
  if (reminderTimers[taskId]) {
    clearTimeout(reminderTimers[taskId]);
  }

  reminderTimers[taskId] = setTimeout(() => {
    fireReminderNotification(taskId, text);
    delete reminderTimers[taskId];
    updateActiveRemindersUI();
  }, delay);

  console.log(`Reminder scheduled for task ${taskId} in ${Math.round(delay / 1000)}s`);
  updateActiveRemindersUI();
}

// Fire the reminder notification with snooze/complete actions
function fireReminderNotification(taskId, text) {
  if (Notification.permission !== 'granted') return;

  const snoozeMin = snoozeDuration ? parseInt(snoozeDuration.value) : 5;

  showNotification('Task Reminder ‚è∞', {
    body: text,
    icon: './icon-192x192.png',
    badge: './icon-192x192.png',
    tag: 'reminder-' + taskId,
    requireInteraction: true,
    vibrate: [300, 100, 300, 100, 300],
    data: {
      type: 'reminder',
      taskId: taskId,
      taskText: text,
      snoozeMinutes: snoozeMin,
      url: './'
    },
    actions: [
      { action: 'snooze', title: 'Snooze ' + snoozeMin + 'min' },
      { action: 'complete', title: 'Complete' }
    ]
  });
}

// Format a datetime string for display
function formatTime(isoString) {
  const d = new Date(isoString);
  return d.toLocaleString(undefined, {
    month: 'short', day: 'numeric',
    hour: 'numeric', minute: '2-digit'
  });
}

// Update the active reminders display
function updateActiveRemindersUI() {
  if (!activeReminders) return;

  const ids = Object.keys(reminderTimers);
  if (ids.length === 0) {
    activeReminders.innerHTML = '';
    return;
  }

  activeReminders.innerHTML =
    '<p class="reminders-label">Active reminders: ' + ids.length + ' pending</p>';
}

// Mark a task as completed in IndexedDB
function completeTask(taskId) {
  const transaction = db.transaction(['tasks'], 'readwrite');
  const objectStore = transaction.objectStore('tasks');
  const getReq = objectStore.get(taskId);

  getReq.onsuccess = () => {
    const task = getReq.result;
    if (!task) return;
    task.completed = true;
    task.reminderTime = null;
    objectStore.put(task);

    // Cancel any pending reminder
    if (reminderTimers[taskId]) {
      clearTimeout(reminderTimers[taskId]);
      delete reminderTimers[taskId];
    }

    console.log('Task completed:', taskId);
    indexedDBResult.textContent = `‚úÖ Task completed: "${task.text}"`;
    indexedDBResult.style.borderColor = '#34a853';
    loadTasks();
    updateActiveRemindersUI();
  };
}

// Snooze a task reminder by a number of minutes
function snoozeTask(taskId, minutes) {
  const transaction = db.transaction(['tasks'], 'readwrite');
  const objectStore = transaction.objectStore('tasks');
  const getReq = objectStore.get(taskId);

  getReq.onsuccess = () => {
    const task = getReq.result;
    if (!task) return;

    const newTime = new Date(Date.now() + minutes * 60 * 1000).toISOString();
    task.reminderTime = newTime;
    objectStore.put(task);

    scheduleReminder(taskId, task.text, newTime);

    console.log(`Task ${taskId} snoozed for ${minutes} minutes`);
    indexedDBResult.textContent = `‚è∞ Snoozed: "${task.text}" ‚Äî reminder in ${minutes}min`;
    indexedDBResult.style.borderColor = '#fbbc04';
    loadTasks();
  };
}

// Load all tasks from IndexedDB
function loadTasks() {
  const transaction = db.transaction(['tasks'], 'readonly');
  const objectStore = transaction.objectStore('tasks');
  const request = objectStore.getAll();

  request.onsuccess = () => {
    const tasks = request.result;
    displayTasks(tasks);

    // Re-schedule any pending reminders for tasks that still have a future reminderTime
    tasks.forEach(task => {
      if (task.reminderTime && !task.completed && !reminderTimers[task.id]) {
        const delay = new Date(task.reminderTime).getTime() - Date.now();
        if (delay > 0) {
          scheduleReminder(task.id, task.text, task.reminderTime);
        }
      }
    });
    updateActiveRemindersUI();
  };

  request.onerror = () => {
    console.error('Error loading tasks:', request.error);
  };
}

// Display tasks in the UI
function displayTasks(tasks) {
  tasksList.innerHTML = '';

  if (tasks.length === 0) {
    tasksList.innerHTML = '<p style="padding: 10px; color: #666;">No tasks yet. Add one above!</p>';
    return;
  }

  tasks.forEach(task => {
    const taskElement = document.createElement('div');
    taskElement.className = 'task-item' + (task.completed ? ' task-completed' : '');

    let reminderBadge = '';
    if (task.reminderTime && !task.completed) {
      const isPast = new Date(task.reminderTime) <= new Date();
      reminderBadge = `<span class="reminder-badge ${isPast ? 'overdue' : ''}">‚è∞ ${formatTime(task.reminderTime)}</span>`;
    }

    let actions = '';
    if (!task.completed) {
      actions = `
        <div class="task-actions">
          <button class="btn-complete-small" onclick="window.completeTask(${task.id})">‚úì</button>
          <button class="btn-delete-small" onclick="window.deleteTask(${task.id})">‚úï</button>
        </div>`;
    } else {
      actions = `
        <div class="task-actions">
          <span class="completed-label">Done</span>
          <button class="btn-delete-small" onclick="window.deleteTask(${task.id})">‚úï</button>
        </div>`;
    }

    taskElement.innerHTML = `
      <div class="task-content">
        <span class="task-text">${task.text}</span>
        ${reminderBadge}
      </div>
      ${actions}
    `;
    tasksList.appendChild(taskElement);
  });
}

// Delete a specific task
window.deleteTask = function(id) {
  const transaction = db.transaction(['tasks'], 'readwrite');
  const objectStore = transaction.objectStore('tasks');
  const request = objectStore.delete(id);

  request.onsuccess = () => {
    if (reminderTimers[id]) {
      clearTimeout(reminderTimers[id]);
      delete reminderTimers[id];
    }
    console.log('Task deleted:', id);
    indexedDBResult.textContent = '‚úÖ Task deleted';
    indexedDBResult.style.borderColor = '#34a853';
    loadTasks();
    updateActiveRemindersUI();
  };

  request.onerror = () => {
    console.error('Error deleting task:', request.error);
    indexedDBResult.textContent = '‚ùå Error deleting task';
    indexedDBResult.style.borderColor = '#ea4335';
  };
};

// Expose completeTask to onclick handlers
window.completeTask = function(id) {
  completeTask(id);
};

// Clear all tasks
function clearAllTasks() {
  const transaction = db.transaction(['tasks'], 'readwrite');
  const objectStore = transaction.objectStore('tasks');
  const request = objectStore.clear();

  request.onsuccess = () => {
    // Cancel all pending reminders
    Object.keys(reminderTimers).forEach(id => {
      clearTimeout(reminderTimers[id]);
      delete reminderTimers[id];
    });

    console.log('All tasks cleared');
    indexedDBResult.textContent = '‚úÖ All tasks cleared';
    indexedDBResult.style.borderColor = '#34a853';
    loadTasks();
    updateActiveRemindersUI();
  };

  request.onerror = () => {
    console.error('Error clearing tasks:', request.error);
    indexedDBResult.textContent = '‚ùå Error clearing tasks';
    indexedDBResult.style.borderColor = '#ea4335';
  };
}

// Event listeners for IndexedDB / Todo List
if (addTaskBtn) {
  addTaskBtn.addEventListener('click', () => {
    const text = taskInput.value.trim();
    if (text) {
      const reminder = taskReminder ? taskReminder.value : '';
      addTask(text, reminder || null);
      taskInput.value = '';
      if (taskReminder) taskReminder.value = '';
    } else {
      indexedDBResult.textContent = '‚ö†Ô∏è Please enter a task';
      indexedDBResult.style.borderColor = '#fbbc04';
    }
  });
}

if (clearTasksBtn) {
  clearTasksBtn.addEventListener('click', () => {
    if (confirm('Are you sure you want to clear all tasks?')) {
      clearAllTasks();
    }
  });
}

// Listen for messages from the service worker (snooze/complete actions)
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.addEventListener('message', (event) => {
    const { action, taskId, snoozeMinutes } = event.data;
    console.log('Message from SW:', event.data);

    if (action === 'snooze' && taskId) {
      snoozeTask(taskId, snoozeMinutes || 5);
    } else if (action === 'complete' && taskId) {
      completeTask(taskId);
    }
  });
}

// Initialize IndexedDB on load
if ('indexedDB' in window) {
  initIndexedDB();
} else {
  indexedDBResult.textContent = '‚ùå IndexedDB not supported';
  indexedDBResult.style.borderColor = '#ea4335';
  addTaskBtn.disabled = true;
  clearTasksBtn.disabled = true;
}
